class Annyang {
    constructor() {
      this.recognition = null;
      this.commands = [];
      this.events = {
        start: [],
        error: [],
        end: [],
        result: [],
        resultMatch: [],
        resultNoMatch: [],
        errorNetwork: [],
        errorPermissionBlocked: [],
        errorPermissionDenied: [],
      };
      this.debugMode = false;
      this.autoRestart = true;
      this.language = 'en-US';
      this.lastResultTimestamp = 0;
    }
  
    init(options = {}) {
      if (!window.SpeechRecognition && !window.webkitSpeechRecognition) {
        console.warn('Speech recognition not supported');
        return;
      }
  
      this.recognition = new (window.SpeechRecognition || window.webkitSpeechRecognition)();
      this.recognition.maxAlternatives = options.maxAlternatives || 5;
      this.recognition.continuous = options.continuous || (window.location.protocol === 'http:');
      this.recognition.lang = options.lang || this.language;
  
      this.recognition.onstart = () => this.emitEvent('start');
      this.recognition.onerror = (event) => this.handleRecognitionError(event);
      this.recognition.onend = () => this.handleRecognitionEnd();
      this.recognition.onresult = (event) => this.handleRecognitionResult(event);
  
      if (options.commands) {
        this.addCommands(options.commands);
      }
  
      if (options.debug) {
        this.debugMode = true;
      }
    }
  
    start() {
      if (!this.recognition) {
        console.warn('Annyang not initialized');
        return;
      }
  
      this.autoRestart = true;
      this.lastResultTimestamp = Date.now();
      this.recognition.start();
    }
  
    abort() {
      this.autoRestart = false;
      if (this.recognition) {
        this.recognition.abort();
      }
    }
  
    debug(enable = true) {
      this.debugMode = enable;
    }
  
    setLanguage(lang) {
      this.language = lang;
      if (this.recognition) {
        this.recognition.lang = lang;
      }
    }
  
    addCommands(commands) {
      for (let phrase in commands) {
        if (commands.hasOwnProperty(phrase)) {
          const command = commands[phrase];
          if (typeof command === 'function') {
            const regex = this.buildCommandRegex(phrase);
            this.commands.push({
              phrase,
              regex,
              callback: command,
            });
          }
        }
      }
      if (this.debugMode) {
        console.log(`Commands successfully loaded: ${this.commands.length}`);
      }
    }
  
    removeCommands(commands) {
      if (!Array.isArray(commands)) {
        commands = [commands];
      }
      this.commands = this.commands.filter((command) => {
        return !commands.includes(command.phrase);
      });
    }
  
    addCallback(eventName, callback, context = null) {
      const event = this.events[eventName];
      if (event) {
        event.push({
          callback,
          context,
        });
      }
    }
  
    buildCommandRegex(phrase) {
      let regex = phrase.trim().replace(/[-[\]{}()+?.,\\^$|#]/g, '\\$&'); // Escape special characters
      regex = regex.replace(/\s*\((.*?)\)\s*/g, '(?:$1)?'); // Convert (optional) groups
      regex = regex.replace(/(\(\?:[^)]+\))\?/g, '\\s*$1?\\s*'); // Convert (optional) non-capturing groups
      regex = regex.replace(/(\(\?)?:\w+/g, function(match, captureGroup) { // Convert named parameters
        return captureGroup ? match : '([^\\s]+)';
      });
      regex = regex.replace(/\*\w+/g, '(.*?)'); // Convert splats
      return new RegExp('^' + regex + '$', 'i');
    }
  
    emitEvent(eventName) {
      const event = this.events[eventName];
      if (event) {
        event.forEach((callback) => {
          callback.callback.apply(callback.context);
        });
      }
    }
  
    handleRecognitionError(event) {
      const error = event.error;
      this.emitEvent('error');
      switch (error) {
        case 'network':
          this.emitEvent('errorNetwork');
          break;
        case 'not-allowed':
        case 'service-not-allowed':
          const permissionEvent = (Date.now() - this.lastResultTimestamp < 200) ? 'errorPermissionBlocked' : 'errorPermissionDenied';
          this.emitEvent(permissionEvent);
          break;
      }
    }
  
    handleRecognitionEnd() {
      this.emitEvent('end');
      if (this.autoRestart) {
        const timeElapsed = Date.now() - this.lastResultTimestamp;
        if (timeElapsed < 1000) {
          setTimeout(() => this.start(), 1000 - timeElapsed);
        } else {
          this.start();
        }
      }
    }
  
    handleRecognitionResult(event) {
      this.emitEvent('result');
      const results = event.results[event.resultIndex];
      for (let i = 0; i < results.length; i++) {
        const transcript = results[i].transcript.trim();
        if (this.debugMode) {
          console.log(`Speech recognized: ${transcript}`);
        }
        if (transcript !== '') {
          for (let j = 0; j < this.commands.length; j++) {
            const command = this.commands[j];
            const matches = command.regex.exec(transcript);
            if (matches) {
              const params = matches.slice(1);
              if (this.debugMode) {
                console.log(`Command matched: ${command.phrase}`);
                if (params.length) {
                  console.log('With parameters:', params);
                }
              }
              command.callback.apply(null, params);
              this.emitEvent('resultMatch');
              return;
            }
          }
        }
      }
      this.emitEvent('resultNoMatch');
    }
  }
  
  const annyang = new Annyang();
  annyang.init();
  window.annyang = annyang;
  